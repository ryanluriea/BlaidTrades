ğŸš¨ SEV-0 / INSTITUTIONAL BLOCKER  
MAKE STRATEGY USAGE PROVABLE (NO LABELING, NO FALLTHROUGH, NO ASSUMPTIONS)

GOAL  
Guarantee â€” and PROVE â€” that every bot is actually executing the strategy it claims to run (e.g. GAP_FADE, RANGE_SCALP, VWAP, etc.).  
This must be fail-closed, auditable, and visible on the bot row.

This is NOT about UI labels.  
This is about execution truth + institutional auditability.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PART A â€” CANONICAL STRATEGY TYPE SYSTEM
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1) SINGLE SOURCE OF TRUTH (MANDATORY)

Create/confirm a shared canonical strategy type file (example):
shared/strategy-types.ts

It must include:

- enum EntryConditionType  
  (GAP_FADE, GAP_FILL, RANGE_SCALP, BREAKOUT, VWAP, TREND, REVERSAL, etc.)

- enum StrategyArchetype  
  (gap_fade, range_scalp, vwap_pullback, momentum_surge, etc.)

- ARCHETYPE_TO_ENTRY_CONDITION mapping  
  (ONE and ONLY ONE mapping path)

- normalizeArchetype(input: string): StrategyArchetype  
  â†’ handles aliases, casing, spacing, prefixes (MES_, MNQ_, etc.)

- assertNever(x: never): never  
  â†’ compile-time exhaustiveness guard

â— REQUIREMENT  
Any unknown archetype MUST throw / fail â€” no default mapping, no fallback.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PART B â€” FACTORY EXHAUSTIVENESS (RULES)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

2) RULE CREATION MUST BE EXHAUSTIVE

In createStrategyRules():

- Switch on EntryConditionType
- Every case implemented explicitly
- default â†’ assertNever()

The rules object MUST embed:
- rules.entryConditionType
- rules.archetype
- rules.rulesHash (deterministic hash of full rules object)
- rules.rulesSummary (human readable, entry/exit/risk/session rules)

â— If a strategy exists in mapping but has no factory case â†’ build must fail.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PART C â€” EXECUTOR FAIL-CLOSED (CRITICAL)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

3) BACKTEST + LIVE EXECUTOR MUST BE EXHAUSTIVE

In backtest executor (and live executor if present):

- Switch on rules.entryConditionType
- Every type implemented explicitly
- default â†’ assertNever()

â— NO silent fallback behavior  
â— NO â€œgenericâ€ execution path  
â— If executor receives unknown/unhandled type â†’ FAIL JOB

If execution fails:
- backtest_session.status = FAILED
- reasonCode = STRATEGY_EXECUTION_MISMATCH

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PART D â€” PROVENANCE / ATTESTATION (PROOF)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

4) STORE EXECUTION PROOF PER BACKTEST

Each backtest_session MUST store:

- expected_entry_condition   (from canonical mapping)
- actual_entry_condition     (what executor actually used)
- rules_hash
- rules_summary
- data_source (REAL_DATABENTO / SIMULATED)
- data_provider
- bar_count
- start_ts / end_ts

FAIL-CLOSED RULE:
If expected_entry_condition !== actual_entry_condition  
â†’ FAIL the backtest with STRATEGY_PROVENANCE_VIOLATION

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PART E â€” TRADE-LEVEL CONFIRMATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

5) TRADE LOGS MUST CONFIRM STRATEGY

Each trade record MUST include:
- entry_reason_code  
  (e.g. ENTRY_GAP_FADE, ENTRY_RANGE_SCALP, ENTRY_VWAP)

This ensures trades themselves confirm the strategy path.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PART F â€” BOT ROW PROOF (UI)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

6) STRATEGY VERIFICATION BADGE (NO FLUFF)

On the bot row show:

- Strategy Name (e.g. â€œGap Fadeâ€)
- Entry Condition (GAP_FADE)
- Verification Badge:
  ğŸŸ¢ VERIFIED â€” expected == actual
  ğŸŸ  MISMATCH â€” executor mismatch detected
  ğŸ”´ ERROR â€” unknown archetype / fail-closed

Tooltip MUST show:
- expected_entry_condition
- actual_entry_condition
- rules_hash
- last_backtest_id

NO badge if bot has never run a backtest.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PART G â€” ACCEPTANCE CRITERIA (NON-NEGOTIABLE)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

This is DONE only when you can show:

1) A GAP_FADE bot:
   - rules.entryConditionType = GAP_FADE
   - executor path = GAP_FADE
   - trade_logs.entry_reason_code = ENTRY_GAP_FADE

2) A RANGE_SCALP bot:
   - rules.entryConditionType = RANGE_SCALP
   - executor path = RANGE_SCALP
   - trade_logs.entry_reason_code = ENTRY_RANGE_SCALP

3) A forced failure case:
   - Unknown archetype â†’ backtest FAILS
   - Error surfaced in UI + logs

4) SQL PROOF:
   SELECT id, expected_entry_condition, actual_entry_condition, rules_hash
   FROM backtest_sessions
   ORDER BY created_at DESC
   LIMIT 10;

5) UI PROOF:
   Screenshot showing VERIFIED badge backed by provenance fields.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
IMPORTANT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â€¢ Mapping â‰  execution  
â€¢ Labels â‰  proof  
â€¢ UI â‰  truth  

This system must be able to survive:
- audits
- handoff to another engineer
- â€œprove itâ€ questions months later

No silent defaults.  
No unreachable code.  
No guessing.

If this is implemented correctly, you will NEVER again wonder:
â€œIs this bot actually using the strategy it says it is?â€

Ship this exactly.
