MASTER PROMPT — SYSTEM STATUS + PROOF OF USE (NO SECRETS, PROFITABILITY-READY)

CONTEXT
We already have a “System Status” page, but we need it upgraded to institutional standards:
1) show which integrations are connected,
2) show evidence they are actually being used by bots (not just “connected”),
3) expose all available variables/signals in a safe way (no secrets) so the platform can use them to improve bot profitability.

ABSOLUTE RULES
- DO NOT expose any secret values anywhere (UI, logs, API, DB).
- Only report: connected boolean, last_success timestamp, last_error code/message (sanitized), latency, and trace_id.
- No mock data and no placeholder “green” states.
- Fail-closed: if a required dependency is missing/unhealthy, autonomy must be blocked and the UI must clearly show BLOCKED + reason.
- Proof must be real, derived from logs/events/rows created by actual bot activity.

GOAL
Upgrade the existing System Status page into a real “Control Plane Observatory” with:
A) Integration Health (connected + probe status)
B) Proof-of-Use (per bot + per subsystem evidence)
C) Variable Catalog (what signals/features are available for bots to use)
D) Autonomy Gate Summary (why a bot can/can’t run autonomously)

===========================================================
PHASE 1 — FIND & EXTEND EXISTING SYSTEM STATUS (NO REWRITES)
===========================================================
1) Locate the existing System Status page and its API endpoints.
2) Keep minimal diffs: extend it rather than replacing it.
3) Identify current status cards/widgets and current data sources.

Deliverable:
- List file paths for the page + components + endpoints currently used.

===========================================================
PHASE 2 — CREATE CANONICAL HEALTH ENDPOINT (SAFE)
===========================================================
Implement (or upgrade) a single endpoint:

GET /api/system/status

Response shape (example):
{
  "success": true,
  "trace_id": "...",
  "ts": "...",
  "integrations": [
    {
      "name": "databento",
      "connected": true,
      "status": "OK|DEGRADED|BLOCKED",
      "required_for_autonomy": true,
      "last_probe_at": "...",
      "last_ok_at": "...",
      "latency_ms": 123,
      "reason_code": null,
      "reason_human": null
    },
    ...
  ],
  "autonomy": {
    "global_status": "OK|DEGRADED|BLOCKED",
    "blockers": [
      { "code": "LIVE_TRADING_DISABLED", "message": "...", "integration": "ironbeam", "trace_id": "..." }
    ]
  }
}

Notes:
- “connected” means env vars exist (boolean only).
- “status” means probe result (OK/DEGRADED/BLOCKED).
- Include required_for_autonomy per integration.

===========================================================
PHASE 3 — PROOF-OF-USE TELEMETRY (THE IMPORTANT PART)
===========================================================
We need proof that integrations are actually used in bot execution/backtests and that
their outputs contribute variables/signals available to profitability logic.

Create a small, safe, append-only telemetry mechanism:
- table: integration_usage_events (preferred) OR reuse an existing audit/events table
- NEVER store secrets; store only metadata.

Minimum schema (or equivalent):
integration_usage_events:
- id (uuid)
- created_at (timestamp)
- user_id (uuid, nullable if system)
- bot_id (uuid, nullable if not bot-specific)
- run_id/job_id (uuid, nullable)
- integration (text)   // databento, polygon, ironbeam, openai, etc.
- operation (text)     // e.g., "marketdata.bars", "broker.place_order", "llm.chat", "risk.check"
- status (text)        // OK|ERROR|BLOCKED
- latency_ms (int, nullable)
- symbol (text, nullable)
- timeframe (text, nullable)
- records (int, nullable)     // bars, ticks, fills count (safe)
- reason_code (text, nullable)
- trace_id (text)
- metadata (jsonb)            // SAFE: model name, endpoint name, regime tag, feature keys USED (not values)

Instrumentation rules:
- Write a usage event on every successful call and on every blocked/failed attempt.
- Tie events to bot_id + run/job when possible.
- For market data: record symbol/timeframe/record count
- For broker: record action type (place/cancel/modify), symbol, qty (optional), status
- For AI: record provider + model + token counts (optional) + “purpose tag” (e.g., coaching, signal extraction), never prompts/responses unless already stored safely.

===========================================================
PHASE 4 — SYSTEM STATUS UI: 4 PANELS
===========================================================
Upgrade the existing System Status page to include:

PANEL A — Integrations Health
- Table of all integrations with: Connected, Status, Last OK, Last Probe, Latency, Required-for-Autonomy, Reason
- Click row -> details drawer with last 20 usage events (sanitized)

PANEL B — Proof of Use (Bots)
- Bot selector (or top 10 most active)
- For selected bot show:
  - Last run/job status + heartbeat + terminal state
  - “Used in last 24h” badges per integration with counts:
    - databento: X calls / Y bars
    - polygon: X calls
    - ironbeam/tradovate: X order intents, X fills
    - openai: X calls, model used
  - Show last trace_id per integration for audit

PANEL C — Variable Catalog (Signals Available)
This is NOT raw data, it’s the feature inventory.
- Produce a canonical list of “variables” the system can provide to bots grouped by source:
  Market Data: OHLCV bars, VWAP, ATR, returns, volatility, session markers…
  Order/Execution: fill latency, slippage estimates, position state, exposure…
  Risk Engine: max contracts, drawdown, violation flags…
  AI: sentiment tags, regime classification outputs, strategy commentary…
- For each variable:
  - name
  - type (number/bool/string)
  - source integration(s)
  - availability (OK/DEGRADED/BLOCKED)
  - last_seen_at (from integration_usage_events metadata “feature_keys_used”)

IMPORTANT:
- This is a catalog of available variables, not a promise they’re profitable.
- No values shown unless already publicly shown in existing UI.

PANEL D — Autonomy Gates
- Show global autonomy state (OK/DEGRADED/BLOCKED)
- List blockers with actionable fix:
  “Missing Ironbeam keys” → “Enter REPLIT secret: IRONBEAM_API_KEY”
  “Databento probe failing” → “Check entitlement / network”
- Each blocker includes trace_id

===========================================================
PHASE 5 — ENFORCE FAIL-CLOSED USING THE SAME TELEMETRY
===========================================================
Whenever a bot run is blocked due to missing data/provider/broker:
- Create integration_usage_event with status=BLOCKED, reason_code
- Ensure UI shows this in both Autonomy Gates and Bot Proof-of-Use

===========================================================
PHASE 6 — ACCEPTANCE TESTS (MUST PROVIDE EVIDENCE)
===========================================================
Provide proof with:
1) Inject a temporary 503 for /api/integrations/health (or equivalent) and show:
   - System Status page flips to DEGRADED/BLOCKED with trace_id
2) Run a bot (paper/shadow) and show usage events created:
   - marketdata usage event(s)
   - risk check usage event(s)
   - runner job/run event(s)
3) If broker not connected, show:
   - broker operations appear as BLOCKED with clear reason (no fake fills)

Deliverables required in FINAL_ACCEPTANCE_GATE.md (or existing doc):
- list of files changed
- endpoint contracts
- example usage event rows (sanitized)
- screenshots optional; logs/SQL outputs acceptable

===========================================================
IMPLEMENTATION CONSTRAINTS
- Minimal diffs; extend existing System Status page.
- Prefer adding small components: UsageEventsTable, IntegrationDrawer, VariableCatalog.
- No new design system; match current styling.
- No secrets in logs. Redact aggressively.

PROCEED NOW
Start by locating the current System Status page and wiring GET /api/system/status.
Then implement integration_usage_events + instrumentation. Then update UI panels A–D.
