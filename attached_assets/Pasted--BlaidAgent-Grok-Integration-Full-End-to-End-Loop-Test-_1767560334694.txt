# BlaidAgent Grok Integration — Full End-to-End Loop Test Plan & Script
# (Single Copy-Paste Block — Run in Replit Console or New Test File — January 04, 2026)

## Test Objective
Verify the complete Grok-bot lifecycle loop:
1. Inject Grok candidate (via API or SQL)
2. Auto-create bot with badge/provenance
3. Run backtest/QC verification
4. Check graduation gates & promote (TRIALS → PAPER → ...)
5. Log injection/promotion in grok_injections
6. Simulate evolution/mutation (if applicable)
7. Check regime decay/drawdown enforcement
8. Human approval simulation for CANARY → LIVE
9. Fail loudly on invalid (e.g., bad rulesJson)

Expected: Successful bots promote based on metrics; failures logged without silent pass.

## Prerequisites (Run Once)
1. Ensure DB schema updated with Grok fields (from prior SQL).
2. Add grok_injections table if not present (from prior SQL).
3. Add /api/grok/inject-candidate endpoint (from prior TypeScript).
4. Have scheduler.ts running (or simulate autonomy loop).
5. QC/Databento APIs configured.

## Step-by-Step Test Script
Create a new file `grok_full_loop_test.ts` in server/ and run via `ts-node grok_full_loop_test.ts`.

```typescript
import { db } from './db';  // Adjust import based on your setup
import { promoteCandidateToBot, runAutonomyLoop } from './scheduler';  // Adjust imports
import fetch from 'node-fetch';  // For API calls

async function testGrokFullLoop() {
  console.log('Starting Grok Full Loop Test...');

  // Step 1: Inject Test Candidate via Dedicated API
  const payload = {
    strategyName: 'Grok Test Momentum Surge',
    archetypeName: 'momentum_surge',
    entryConditionType: 'MOMENTUM_SURGE',
    instrumentUniverse: ['MNQ'],
    timeframePreferences: ['5m'],
    sessionModePreference: 'RTH_US',
    hypothesis: 'Test hypothesis for full loop verification.',
    rulesJson: {
      version: '1.0.0',
      archetype: 'momentum_surge',
      entry: { condition: { type: 'MOMENTUM_SURGE', trendEmaShort: 9, trendEmaLong: 21 }, confirmations: [{ type: 'VOLUME', volumeMultiplier: 1.5 }] },
      exit: { stopLoss: [{ type: 'FIXED_TICKS', ticks: 16 }], takeProfit: [{ type: 'FIXED_TICKS', ticks: 24 }] },
      risk: { maxPositionSize: 2, riskPerTrade: 1.0, maxDailyLoss: 3.0 }
    },
    confidenceScore: 90,
    noveltyScore: 85,
    disposition: 'AUTO_CREATE_BOT',
    source: 'EXTERNAL_AI'
  };

  const apiResponse = await fetch('http://localhost:3000/api/grok/inject-candidate', {  // Adjust port
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
  const apiData = await apiResponse.json();
  console.log('Injection Response:', apiData);
  const candidateId = apiData.candidateId;

  // Step 2: Verify Auto-Create Bot & Badge
  const bot = await db.selectFrom('bots').where('name', 'ilike', '%Grok Test%').executeTakeFirst();
  console.log('Created Bot:', bot);
  if (!bot || !bot.grok_badge) throw new Error('Bot creation or badge failed');

  // Step 3: Trigger QC Verification & Backtest
  const qcResponse = await fetch(`http://localhost:3000/api/strategy-lab/candidates/${candidateId}/qc-verification`, {
    method: 'POST'
  });
  const qcData = await qcResponse.json();
  console.log('QC Verification:', qcData);

  // Simulate backtest completion (in prod, wait for callback)
  // Manually update bot metrics to pass TRIALS gates (for test)
  await db.updateTable('bots').set({
    liveTotalTrades: 60,
    liveWinRate: 42,
    liveMaxDrawdownPct: 18,
    liveProfitFactor: 1.4,
    liveSharpe: 0.6
  }).where('id', '=', bot.id).execute();

  // Step 4: Run Autonomy Loop for Promotion
  await runAutonomyLoop();
  const updatedBot = await db.selectFrom('bots').where('id', '=', bot.id).executeTakeFirst();
  console.log('Post-Promotion Bot Stage:', updatedBot.stage);  // Expect PAPER if gates pass

  // Step 5: Check Logging
  const log = await db.selectFrom('grok_injections').where('bot_id', '=', bot.id).executeTakeFirst();
  console.log('Injection Log:', log);
  if (!log) throw new Error('Logging failed');

  // Step 6: Simulate Evolution/Mutation
  // Inject mutated version via API (new candidate linked to original)
  const mutatePayload = { ...payload, strategyName: 'Grok Test Mutated v2', rulesJson: { ...payload.rulesJson, entry: { ...payload.rulesJson.entry, trendEmaShort: 10 } } };
  await fetch('http://localhost:3000/api/grok/inject-candidate', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(mutatePayload) });

  // Step 7: Simulate Regime Decay/Drawdown Failure
  // Update to fail gates
  await db.updateTable('bots').set({ liveMaxDrawdownPct: 22 }).where('id', '=', bot.id).execute();
  await runAutonomyLoop();
  const failedBot = await db.selectFrom('bots').where('id', '=', bot.id).executeTakeFirst();
  console.log('After Failure:', failedBot.stage);  // Expect no promotion or demotion log

  // Step 8: Simulate Human Approval for CANARY → LIVE
  // Manually set to CANARY, then approve
  await db.updateTable('bots').set({ stage: 'CANARY' }).where('id', '=', bot.id).execute();
  // Assume manual approval endpoint or flag
  // POST /api/bots/:id/approve-live (implement if needed)
  console.log('Simulated LIVE Approval — Test Complete');

  console.log('Full Loop Test Passed!');
}

testGrokFullLoop().catch(console.error);